<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="c:\program files (x86)\microsoft visual studio 14.0\team tools\static analysis tools\fxcop\Xml\CodeAnalysisReport.xsl"?>
<FxCopReport Version="14.0">
 <Targets>
  <Target Name="D:\5_H_Talk_Project\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\bin\Debug\EpLibrary.cs.dll">
   <Modules>
    <Module Name="eplibrary.cs.dll">
     <Namespaces>
      <Namespace Name="EpLibrary.cs">
       <Types>
        <Type Name="BaseTextFile" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'StreamWriter', 'StreamReader'의 멤버가 만들어지므로 'BaseTextFile'에 IDisposable을 구현하십시오. 'BaseTextFile'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="BinaryFile" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'MemoryStream', 'BinaryWriter', 'BinaryReader'의 멤버가 만들어지므로 'BinaryFile'에 IDisposable을 구현하십시오. 'BinaryFile'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="BinarySerializer" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'MemoryStream', 'BinaryWriter', 'BinaryReader'의 멤버가 만들어지므로 'BinarySerializer'에 IDisposable을 구현하십시오. 'BinarySerializer'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#FinishedSerializing()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="개체를 여러 번 삭제하지 마십시오." Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\SilverlightSerialization" File="SerializationUnits.cs" Line="201">'stream' 개체는 'BinarySerializer.FinishedSerializing()' 메서드에서 여러 번 삭제할 수 있습니다. System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.: Lines: 201</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#StartDeserializing()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="개체를 여러 번 삭제하지 마십시오." Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\SilverlightSerialization" File="SerializationUnits.cs" Line="424">'stream' 개체는 'BinarySerializer.StartDeserializing()' 메서드에서 여러 번 삭제할 수 있습니다. System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.: Lines: 424</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="CmdLineOptions" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="NonBreaking">
           <Issue Certainty="75" Level="Warning">이 형식이 ISerializable을 구현할 때 'CmdLineOptions'에 [Serializable]을 추가하십시오.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="CrcCalculatorStream" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="Breaking">
           <Issue Name="IDisposableReimplementation" Certainty="95" Level="Error">'CrcCalculatorStream'에서 구현된 인터페이스 목록에서 IDisposable을 제거하고 대신 기본 클래스 Dispose 구현을 재정의하십시오.</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#System.IDisposable.Dispose()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\DotNetZip" File="CRC32.cs" Line="798">현재 개체 인스턴스(Visual Basic의 경우 'this' 또는 'Me')에서 Dispose(true)를 호출하고 GC.SuppressFinalize를 호출한 후 반환하도록 'CrcCalculatorStream.IDisposable.Dispose()'을(를) 수정하십시오.</Issue>
             <Issue Name="RenameDispose" Certainty="95" Level="Error" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\DotNetZip" File="CRC32.cs" Line="798">'CrcCalculatorStream.IDisposable.Dispose()'을(를) 'Dispose'로 이름을 바꾸고 public 및 sealed로 선언되어 있는지 확인하십시오.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="DeflateStream" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Length" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Length()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\DotNetZip" File="DeflateStream.cs" Line="505">'DeflateStream.Length.get()'이(가) 속성에서 발생하면 안 되는 'NotImplementedException' 형식의 예외를 만듭니다. 이러한 예외 인스턴스가 발생할 수 있는 경우에는 다른 예외 형식을 사용하거나 이 속성을 메서드로 변환하거나 이 속성의 논리를 변경하여 예외가 더 이상 발생하지 않도록 하십시오.</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="EventEx" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'EventWaitHandle'의 멤버가 만들어지므로 'EventEx'에 IDisposable을 구현하십시오. 'EventEx'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="FolderHelper" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetModuleFileName(System.IntPtr,System.Text.StringBuilder,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">'FolderHelper.GetModuleFileName(IntPtr, StringBuilder, int)'은(는) P/Invoke 메서드이므로 NativeMethods, SafeNativeMethods 또는 UnsafeNativeMethods 클래스에 정의해야 합니다.</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">보안 위험을 줄이려면 DllImport.CharSet을 CharSet.Unicode로 설정하거나 'lpFilename' 매개 변수를 명시적으로 UnmanagedType.LPWStr로 마샬링하여 매개 변수를 유니코드로 마샬링하십시오. 이 문자열을 ANSI 또는 시스템 설정으로 마샬링하려면 명시적으로 MarshalAs를 지정하고 BestFitMapping=false를 설정하십시오. 또한 ThrowOnUnmappableChar=true를 설정하여 보안을 강화하십시오.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="GZip" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Compress(System.Byte[])" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="개체를 여러 번 삭제하지 마십시오." Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\Framework\Compression" File="GZip.cs" Line="134">'memory' 개체는 'GZip.Compress(byte[])' 메서드에서 여러 번 삭제할 수 있습니다. System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.: Lines: 134</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Compress(System.Byte[],System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="개체를 여러 번 삭제하지 마십시오." Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\Framework\Compression" File="GZip.cs" Line="184">'memory' 개체는 'GZip.Compress(byte[], int, int)' 메서드에서 여러 번 삭제할 수 있습니다. System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.: Lines: 184</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="GZipStream" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Length" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Length()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\DotNetZip" File="GZipStream.cs" Line="713">'GZipStream.Length.get()'이(가) 속성에서 발생하면 안 되는 'NotImplementedException' 형식의 예외를 만듭니다. 이러한 예외 인스턴스가 발생할 수 있는 경우에는 다른 예외 형식을 사용하거나 이 속성을 메서드로 변환하거나 이 속성의 논리를 변경하여 예외가 더 이상 발생하지 않도록 하십시오.</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="IpcClient" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'NamedPipeClientStream'의 멤버가 만들어지므로 'IpcClient'에 IDisposable을 구현하십시오. 'IpcClient'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="IpcPipe" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'NamedPipeServerStream'의 멤버가 만들어지므로 'IpcPipe'에 IDisposable을 구현하십시오. 'IpcPipe'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="MutexEx" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'Mutex'의 멤버가 만들어지므로 'MutexEx'에 IDisposable을 구현하십시오. 'MutexEx'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="OpenFileDialogEx" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'OpenFileDialog'의 멤버가 만들어지므로 'OpenFileDialogEx'에 IDisposable을 구현하십시오. 'OpenFileDialogEx'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="OpenFolderDialog" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'FolderBrowserDialog'의 멤버가 만들어지므로 'OpenFolderDialog'에 IDisposable을 구현하십시오. 'OpenFolderDialog'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="OpenMultiFileDialog" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'OpenFileDialog'의 멤버가 만들어지므로 'OpenMultiFileDialog'에 IDisposable을 구현하십시오. 'OpenMultiFileDialog'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="ParallelDeflateOutputStream" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\DotNetZip" File="ParallelDeflateOutputStream.cs" Line="781">현재 개체 인스턴스(Visual Basic의 경우 'this' 또는 'Me')에서 Dispose(true)를 호출하고 GC.SuppressFinalize를 호출한 후 반환하도록 'ParallelDeflateOutputStream.Dispose()'을(를) 수정하십시오.</Issue>
             <Issue Name="DisposeSignature" Certainty="95" Level="Error" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\DotNetZip" File="ParallelDeflateOutputStream.cs" Line="781">'ParallelDeflateOutputStream.Dispose()'이(가) public 및 sealed로 선언되어 있는지 확인하십시오.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Dispose(System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="_newlyCompressedBlob" TypeName="DisposableFieldsShouldBeDisposed" Category="Microsoft.Usage" CheckId="CA2213" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\DotNetZip" File="ParallelDeflateOutputStream.cs" Line="795">'ParallelDeflateOutputStream'에 IDisposable 형식 'AutoResetEvent'의 'ParallelDeflateOutputStream._newlyCompressedBlob' 필드가 있습니다. 'ParallelDeflateOutputStream'의 Dispose 메서드를 변경하여 이 필드에 대해 Dispose 또는 Close를 호출하십시오.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SaveFileDialogEx" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
           <Issue Name="DependsOnFix" Certainty="95" Level="CriticalError">IDisposable 형식 'SaveFileDialog'의 멤버가 만들어지므로 'SaveFileDialogEx'에 IDisposable을 구현하십시오. 'SaveFileDialogEx'이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="SilverlightSerializer+MissingConstructorException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="Error">이 형식이 ISerializable을 구현할 때 'SilverlightSerializer.MissingConstructorException'에 [Serializable]을 추가하십시오.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="TaskbarNotifier" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ShowWindow(System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">'TaskbarNotifier.ShowWindow(IntPtr, int)'은(는) P/Invoke 메서드이므로 NativeMethods, SafeNativeMethods 또는 UnsafeNativeMethods 클래스에 정의해야 합니다.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="WebRequestEx" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DownloadFile(System.String,System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="개체를 여러 번 삭제하지 마십시오." Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\Framework" File="WebRequestEx.cs" Line="142">'stream' 개체는 'WebRequestEx.DownloadFile(string, string, int)' 메서드에서 여러 번 삭제할 수 있습니다. System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.: Lines: 142</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DownloadFileAsync(System.String,System.String,System.Action`1&lt;EpLibrary.cs.DownloadFileStatus&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="개체를 여러 번 삭제하지 마십시오." Category="Microsoft.Usage" CheckId="CA2202" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="D:\99_사원 정재훈\오픈소스\EpServerEngine.cs\EpLibrary.cs\EpLibrary.cs\EpLibrary.cs\Framework" File="WebRequestEx.cs" Line="201">'stream' 개체는 'WebRequestEx.DownloadFileAsync(string, string, Action&lt;DownloadFileStatus&gt;)' 메서드에서 여러 번 삭제할 수 있습니다. System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.: Lines: 201</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ZlibException" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237" Status="Active" Created="2019-01-07 04:13:44Z" FixCategory="NonBreaking">
           <Issue Certainty="95" Level="Error">이 형식이 ISerializable을 구현할 때 'ZlibException'에 [Serializable]을 추가하십시오.</Issue>
          </Message>
         </Messages>
        </Type>
       </Types>
      </Namespace>
     </Namespaces>
    </Module>
   </Modules>
  </Target>
 </Targets>
 <Rules>
  <Rule TypeName="DisposableFieldsShouldBeDisposed" Category="Microsoft.Usage" CheckId="CA2213">
   <Name>삭제 가능한 필드는 삭제해야 합니다.</Name>
   <Description>IDisposable을 구현하는 형식은 IDisposable을 구현하는 필드도 소유합니다. 형식의 Dispose() 구현을 캡슐화하면 삭제 가능한 각 필드에 대해 Dispose()를 호출해야 합니다.</Description>
   <Resolution Name="Default">{0}에 IDisposable 형식 {2}의 {1} 필드가 있습니다. {0}의 Dispose 메서드를 변경하여 이 필드에 대해 Dispose 또는 Close를 호출하십시오.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182328.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065">
   <Name>예기치 않은 위치에서 예외를 발생시키지 마십시오.</Name>
   <Description>예기치 않은 위치에서 명시적으로 예외를 발생시키지 마십시오. Equals 및 GetHashCode 같은 일부 메서드에서는 예외를 발생시키지 않아야 합니다. 따라서 이러한 메서드에 대한 호출은 일반적으로 try catch 블록에 래핑되지 않습니다.</Description>
   <Resolution Name="PropertyGetter">{0}이(가) 속성에서 발생하면 안 되는 {1} 형식의 예외를 만듭니다. 이러한 예외 인스턴스가 발생할 수 있는 경우에는 다른 예외 형식을 사용하거나 이 속성을 메서드로 변환하거나 이 속성의 논리를 변경하여 예외가 더 이상 발생하지 않도록 하십시오.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb386039.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error, Warning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063">
   <Name>IDisposable을 올바르게 구현하십시오.</Name>
   <Description>모든 IDisposable 형식은 Dispose 패턴을 올바르게 구현해야 합니다.</Description>
   <Resolution Name="DisposeImplementation">현재 개체 인스턴스(Visual Basic의 경우 'this' 또는 'Me')에서 Dispose(true)를 호출하고 GC.SuppressFinalize를 호출한 후 반환하도록 {0}을(를) 수정하십시오.</Resolution>
   <Resolution Name="DisposeSignature">{0}이(가) public 및 sealed로 선언되어 있는지 확인하십시오.</Resolution>
   <Resolution Name="IDisposableReimplementation">{0}에서 구현된 인터페이스 목록에서 IDisposable을 제거하고 대신 기본 클래스 Dispose 구현을 재정의하십시오.</Resolution>
   <Resolution Name="RenameDispose">{0}을(를) 'Dispose'로 이름을 바꾸고 public 및 sealed로 선언되어 있는지 확인하십시오.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms244737.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MarkISerializableTypesWithSerializable" Category="Microsoft.Usage" CheckId="CA2237">
   <Name>SerializableAttribute로 ISerializable 형식 표시</Name>
   <Description>System.Runtime.Serialization.ISerializable 인터페이스는 형식에서 serialization을 사용자 지정할 수 있습니다. Serializable 특성을 사용하면 런타임에서 형식을 serialize할 수 있는 것으로 인식할 수 있습니다.</Description>
   <Resolution Name="Default">이 형식이 ISerializable을 구현할 때 {0}에 [Serializable]을 추가하십시오.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182350.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060">
   <Name>P/Invoke를 NativeMethods 클래스로 이동</Name>
   <Description>이 형식에는 DllImport 특성을 가진 멤버가 들어 있습니다. DllImport 특성을 가진 멤버는 NativeMethods, SafeNativeMethods 또는 UnsafeNativeMethods 클래스에 들어 있어야 합니다.</Description>
   <Resolution Name="Default">{0}은(는) P/Invoke 메서드이므로 NativeMethods, SafeNativeMethods 또는 UnsafeNativeMethods 클래스에 정의해야 합니다.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182161.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101">
   <Name>P/Invoke 문자열 인수에 대해 마샬링을 지정하십시오.</Name>
   <Description>문자열을 ANSI(Win9x의 경우 Auto)로 마샬링하는 경우 일부 문자가 변경될 수 있습니다. BestFitMapping이 설정되어 있으면 유니코드에서 다르게 나타나는 문자열이 동일한 ANSI 문자열로 마샬링되므로 이로 인해 올바르지 않은 보안 결정을 내릴 수 있습니다. 최적 문자 매핑을 해제하면 동일한 문자가 없는 문자가 모두 '?'에 매핑되므로 이러한 위험이 줄어듭니다. 또한 모든 문자열 마샬링에 대한 기본 설정은 CharSet.Ansi입니다. 유니코드 마샬링은 DllImport나 StructLayout의 CharSet 설정으로 또는 유니코드(또는 시스템 설정) UnmanagedType을 사용하여 MarshalAs 특성으로 명시적으로 지정해야 합니다.</Description>
   <Resolution Name="ParameterImplicitAnsi">보안 위험을 줄이려면 DllImport.CharSet을 CharSet.Unicode로 설정하거나 {0} 매개 변수를 명시적으로 UnmanagedType.LPWStr로 마샬링하여 매개 변수를 유니코드로 마샬링하십시오. 이 문자열을 ANSI 또는 시스템 설정으로 마샬링하려면 명시적으로 MarshalAs를 지정하고 BestFitMapping=false를 설정하십시오. 또한 ThrowOnUnmappableChar=true를 설정하여 보안을 강화하십시오.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182319.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="TypesThatOwnDisposableFieldsShouldBeDisposable" Category="Microsoft.Design" CheckId="CA1001">
   <Name>삭제 가능한 필드가 있는 형식은 삭제 가능해야 합니다.</Name>
   <Description>삭제 가능한 멤버를 선언하는 형식은 IDisposable도 구현해야 합니다. 이 형식에 관리되지 않는 리소스가 없는 경우 형식에 종료자를 구현하지 마십시오.</Description>
   <Resolution Name="DependsOnFix">IDisposable 형식 {1}의 멤버가 만들어지므로 {0}에 IDisposable을 구현하십시오. {0}이(가) 이전에 제공된 경우 이 형식에 IDisposable을 구현하는 새 멤버를 추가하면 기존 소비자가 빌드되지 않습니다.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182172.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="개체를 여러 번 삭제하지 마십시오." Category="Microsoft.Usage" CheckId="CA2202">
   <Name>개체를 여러 번 삭제하지 마십시오.</Name>
   <Description>올바로 구현된 Dispose 메서드는 예외를 throw하지 않고 여러 번 호출할 수 있습니다. 그러나 확실하지는 않으므로 System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.</Description>
   <Resolution Name="Default">{0} 개체는 {1} 메서드에서 여러 번 삭제할 수 있습니다. System.ObjectDisposedException이 생성되지 않도록 개체에 대해 Dispose를 여러 번 호출하지 마십시오.: Lines: 201</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182334.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="14.0.0.0" />
  </Rule>
 </Rules>
 <Localized>
  <String Key="Category">범주</String>
  <String Key="Certainty">확신도</String>
  <String Key="CollapseAll">모두 축소</String>
  <String Key="CheckId">확인 ID</String>
  <String Key="Error">오류</String>
  <String Key="Errors">개 오류</String>
  <String Key="ExpandAll">모두 확장</String>
  <String Key="Help">도움말</String>
  <String Key="Line">줄</String>
  <String Key="Messages">메시지</String>
  <String Key="LocationNotStoredInPdb">[Pdb에 위치가 저장되지 않음]</String>
  <String Key="Project">프로젝트</String>
  <String Key="Resolution">확인</String>
  <String Key="Rule">규칙</String>
  <String Key="RuleFile">규칙 파일</String>
  <String Key="RuleDescription">규칙 설명</String>
  <String Key="Source">소스</String>
  <String Key="Status">상태</String>
  <String Key="Target">대상</String>
  <String Key="Warning">경고</String>
  <String Key="Warnings">경고</String>
  <String Key="ReportTitle">코드 분석 보고서</String>
 </Localized>
</FxCopReport>
